# JS 기본 동작원리, “진짜 뼈대”만 잡아보기

JS 공부하다 보면 어느 순간 이런 상태가 된다.

> “콜스택? 이벤트루프? 비동기?
>
> 머리로는 아는데… 왜 그런지 느낌이 안 와…”

그래서 오늘은 **기본기에 충실하게**

“JS가 어떻게 실행되고, 비동기는 어떻게 굴러가며, 브라우저/Node는 뭐가 다른지”를 **뼈대 중심**으로 정리해본다.

---

## 0. 한 문장 요약부터

JS의 실행은 결국 이거다.

> JS는 싱글 스레드로 콜스택에서 실행되고, 비동기는 호스트(브라우저/Node)가 맡았다가 큐에 넣고, 이벤트 루프가 스택이 빌 때 다시 실행시킨다.

이 한 줄이 이해되면 나머지 개념은 다 “그림 맞추기”가 된다.

---

## 1. JS는 어디서 실행되냐?

### 브라우저

브라우저는 내부에 **JS 엔진**이 있다.

- Chrome / Edge: V8
- Firefox: SpiderMonkey
- Safari: JavaScriptCore

브라우저에서 JS는 보통 HTML 파싱 중 `<script>` 만나면 실행된다.

(기본은 DOM 생성 잠깐 멈추고 JS부터 실행하는 흐름)

### Node.js

Node는 브라우저 없이도 JS를 돌리게 해주는 런타임.

- JS 엔진(V8 같은 것) + 시스템 기능(파일, 네트워크 등)을 묶어줌
- 이벤트 루프/I/O는 보통 **libuv** 기반

즉 **브라우저냐 Node냐**는 “JS 문법” 차이가 아니라,

> JS 엔진이 붙어있는 ‘호스트 환경’이 다르다
>
> (브라우저는 DOM/렌더링, Node는 파일/서버/CLI)

이 차이임.

---

## 2. JS 엔진의 핵심 구조: Heap + Call Stack

JS 실행 원리를 이해할 때 제일 먼저 잡아야 할 두 개:

### 2-1) Memory Heap

- 객체/배열/함수 같은 **데이터 덩어리**가 저장되는 공간
- 참조가 끊기면 GC가 정리함 (가비지 컬렉션)

### 2-2) Call Stack

- “지금 실행 중인 함수가 뭔지”를 쌓아두는 스택(LIFO)
- **함수 호출 → push**, 함수 종료 → pop

예를 들어 이런 코드:

```jsx
functionadd(a, b) {
return a + b;
}

functionavg(a, b) {
returnadd(a, b) /2;
}

console.log(avg(10,20));

```

실행 흐름 느낌:

1. `console.log(...)` push
2. `avg(...)` push
3. `add(...)` push
4. add 끝 → pop
5. avg 끝 → pop
6. log 끝 → pop

**스택이 비는 순간**이 엄청 중요하다.

왜냐면 그때 비동기 콜백들이 “들어올 기회”를 얻기 때문.

---

## 3. JS는 싱글 스레드다 (이게 모든 것의 시작)

JS는 기본적으로 **한 번에 한 줄기 실행(싱글 스레드)** 이다.

그래서 콜스택에 무거운 일이 걸리면:

- 클릭 이벤트 처리도 못 하고
- setTimeout 콜백도 못 하고
- 화면 업데이트도 밀리고
- 체감은 “버벅임”으로 나타남

즉,

> 메인 스레드(콜스택)가 막히면 모든 게 멈춘다.

그런데도 웹에서는 “동시에 여러 일”이 되는 것처럼 보이잖아?

그걸 가능하게 하는 게 다음 파트.

---

## 4. 비동기는 누가 해주냐? (Web APIs / Node APIs)

중요 포인트:

> setTimeout, 네트워크 요청, DOM 이벤트 같은 건
>
> **JS 엔진이 직접 처리하는 게 아니다.**

### 브라우저라면

- Web APIs(타이머, fetch/XHR, DOM 이벤트 등)가 맡는다.

### Node라면

- Node의 시스템 API(파일 I/O, 네트워크 등)가 맡고
- 내부적으로 이벤트 루프/libuv가 돌려준다.

즉 JS는 “요청만 던지고”, 실제 작업은 호스트가 처리한 뒤

완료되면 “콜백을 큐에 넣어” 다시 JS로 돌아오게 한다.

---

## 5. 큐가 2개다: Task Queue / Microtask Queue

이거 체감상 제일 중요함. 실행 순서가 여기서 갈린다.

### 5-1) Task Queue (매크로태스크)

대략 이런 애들이 여기 들어온다:

- `setTimeout`, `setInterval`
- 사용자 이벤트(click 등)
- (환경에 따라) 메시지 이벤트 등

### 5-2) Microtask Queue

대략 이런 애들이 여기에 들어온다:

- `Promise.then / catch / finally`
- `queueMicrotask`
- (브라우저) MutationObserver 등

그리고 **마이크로태스크가 우선순위가 더 높다.**

---

## 6. Event Loop: “스택 비면, 큐에서 꺼내서 실행”

이벤트 루프를 어렵게 말하면 복잡한데, 진짜 뼈대는 이거야:

1. 콜스택이 비었나 확인
2. 비었으면 **Task Queue에서 하나 꺼내 실행**
3. 그 Task가 끝나면 **Microtask를 먼저 싹 비움**
4. 다음 Task로 넘어감

여기서 “마이크로태스크를 먼저 싹 비운다”가 포인트.

---

## 7. 실행 순서 감 잡기 예제 (국룰)

```jsx
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");
```

대부분 결과:

> A → D → C → B

이유:

- A, D는 동기라서 콜스택에서 즉시 실행
- Promise.then은 **Microtask**
- setTimeout은 **Task**
- 그래서 **microtask가 task보다 먼저 끼어든다**

---

## 8. “0ms setTimeout인데 왜 바로 안 찍힘?”의 정체

`setTimeout(fn, 0)`은 **“지금 당장”**이 아니라

> “최소 0ms 뒤에, Task Queue에 넣어줄게”
>
> (단, 콜스택이 비어야 실행됨)

이라서, 이미 스택이 바쁘면 계속 밀린다.

---

## 9. Node에서도 결국 뼈대는 같다

Node도 본질은 동일하다.

- JS는 콜스택에서 실행 (싱글 스레드)
- 비동기 작업은 호스트가 처리
- 완료되면 큐에 넣고 이벤트 루프가 다시 실행

차이는 “호스트가 제공하는 기능”이 다르다는 점:

- 브라우저: DOM/렌더링/이벤트 중심
- Node: 파일/네트워크/서버/CLI 중심

---

## 오늘의 결론 (내가 이해한 버전)

- JS 실행의 중심은 **Call Stack**이다.
- 비동기는 **호스트(Web APIs/Node APIs)** 가 처리하고
- 완료된 콜백은 **큐**에 들어갔다가
- **Event Loop**가 **스택이 비었을 때** 다시 실행시킨다.
- 그리고 **Promise 계열(Microtask)이 setTimeout(Task)보다 먼저 실행되는 경우가 많다.**
